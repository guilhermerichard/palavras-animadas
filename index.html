<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Palavras Animadas — Timer</title>
<style>
    :root{
        --bg:#05030a;
        --accent:#7be3ff;
        --muted:rgba(255,255,255,0.12);
    }
    html,body{height:100%;margin:0;font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{
        background: radial-gradient(circle at 15% 10%, rgba(123,227,255,0.04), transparent 6%),
                    linear-gradient(180deg, #05030a 0%, #06061a 100%);
        color:#fff;
        overflow:hidden;
    }

    /* Canvas fundo (partículas) */
    #bg-canvas{ position:fixed; inset:0; z-index:0; display:block; }

    /* Contêiner principal */
    .stage{ position:relative; width:100%; height:100%; z-index:2; display:flex; align-items:center; justify-content:center; pointer-events:none; }

    /* Área central: relógio + palavra */
    .center-wrap{
        pointer-events:auto;
        text-align:center;
        transform-style:preserve-3d;
    }

    #timer {
        font-weight:700;
        font-size: clamp(18px, 3.2vw, 34px);
        color: var(--accent);
        margin-bottom: 8px;
        text-shadow: 0 3px 14px rgba(0,0,0,0.6);
    }

    #palavra-central { position:relative; transform-style:preserve-3d; text-align:center; font-weight:800; letter-spacing:0.02em; color: #ffffff; text-shadow: 0 6px 18px rgba(0,0,0,0.6), 0 0 24px rgba(123,227,255,0.06); user-select:none; }
    #palavra-central .texto { display:inline-block; font-size: clamp(32px, 8vw, 96px); transition: transform 420ms cubic-bezier(.2,.9,.25,1), opacity 350ms ease; transform-origin:center center; }

    .burst { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:240px; height:240px; pointer-events:none; filter: blur(8px); opacity:0; }
    .burst.show { opacity:1; animation: burstIn 420ms ease-out forwards; }
    @keyframes burstIn { 0% { transform: translate(-50%,-50%) scale(0.4); opacity:0.9; filter: blur(20px); } 100%{ transform: translate(-50%,-50%) scale(1.0); opacity:0; filter: blur(0px); } }

    /* Controles flutuantes (esquerda cima) */
    .controls { position:fixed; top:18px; left:18px; z-index:6; display:flex; gap:10px; pointer-events:auto; align-items:center; }
    .btn { background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); border: 1px solid rgba(255,255,255,0.06); color: white; padding:10px 14px; border-radius:10px; font-size:15px; cursor:pointer; backdrop-filter: blur(6px); box-shadow: 0 6px 18px rgba(11,14,24,0.6); }
    .btn:hover{ transform: translateY(-2px); }

    /* Nav direita */
    .nav { position:fixed; right:18px; top:18px; z-index:6; display:flex; gap:10px; pointer-events:auto; }
    .round { width:52px; height:52px; border-radius:12px; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:20px; }

    /* Histórico no canto inferior direito - agora está fixo e cresce pra cima */
    #lista { position:fixed; right:20px; bottom:20px; z-index:6; text-align:right; max-width:320px; pointer-events:auto; color: rgba(255,255,255,0.86); font-size:16px;
            display:flex; flex-direction:column; justify-content:flex-end; gap:8px; }
    #lista .titulo { font-size:13px; color:var(--muted); margin-bottom:6px; text-align:right; }
    #lista .item { display:block; padding:6px 10px; border-radius:10px; background: linear-gradient(90deg, rgba(255,255,255,0.02), transparent); margin:0; transform-origin:right center; transition: transform 300ms ease, opacity 300ms ease; opacity:0.95; }

    /* flying word */
    .flying { position:fixed; z-index:5; pointer-events:none; font-weight:800; color:white; text-shadow: 0 6px 18px rgba(0,0,0,0.6); }

    .typewriter { border-right: 3px solid rgba(255,255,255,0.85); padding-right:6px; animation: blinkCursor 900ms steps(1) infinite; }
    @keyframes blinkCursor { from{border-right-color:rgba(255,255,255,0.85);} to{border-right-color:transparent;} }

    /* slider area */
    .slider-wrap { display:flex; gap:12px; align-items:center; color:var(--muted); margin-left:8px; }
    input[type="range"] { width:200px; }

    .hint { position:fixed; left:50%; transform:translateX(-50%); bottom:12px; z-index:6; color:rgba(255,255,255,0.6); font-size:13px; pointer-events:none; }

    @media (max-width:640px){
        #lista{ right:10px; left:10px; text-align:center; max-width:none; }
        .controls { flex-direction:column; gap:8px; }
        input[type="range"]{ width:120px; }
    }
</style>
</head>
<body>

<canvas id="bg-canvas"></canvas>

<!-- Controls: Gerar / Shuffle + slider -->
<div class="controls">
    <button class="btn" id="btn-gerar" title="Gerar novas palavras">Gerar Novas Palavras</button>
    <button class="btn" id="btn-shuffle" title="Embaralhar restante">Embaralhar</button>
    <div class="slider-wrap" title="Tempo (segundos)">
        <label for="timeRange" style="font-size:14px;color:var(--muted)">Tempo:</label>
        <input id="timeRange" type="range" min="1" max="60" value="5" />
        <div id="timeValue" style="min-width:36px;text-align:right;font-weight:700;color:var(--accent)">5s</div>
    </div>
</div>

<!-- Nav (setas) -->
<div class="nav">
    <button class="btn round" id="btn-voltar" title="Voltar (←)">←</button>
    <button class="btn round" id="btn-avancar" title="Avançar (→)">→</button>
</div>

<!-- Centro: timer + palavra -->
<div class="stage" aria-hidden="true">
    <div class="center-wrap" style="pointer-events:auto; z-index:4;">
        <div id="timer">00:00</div>
        <div id="palavra-central" aria-live="polite">
            <div class="texto">Pronto</div>
            <div class="burst" id="burst"></div>
        </div>
    </div>
</div>

<!-- Lista (histórico) -->
<div id="lista" aria-hidden="false">
    <div class="titulo">Palavras mostradas</div>
</div>

<div class="hint">Use ← e → ou os botões. O timer inicia quando você avança.</div>

<script>
/* =========================
   BASE / UTILS
   ========================= */
const BASE = [
    "Amor","Força","Destino","Vitória","Alegria","Paz","Energia","Natureza","Luz","Esperança",
    "Sabedoria","Caminho","União","Vida","Magia","Coragem","Liberdade","Paixão","Futuro","Mistério",
    "Sorte","Criatividade","Beleza","Verdade","Equilíbrio","Conquista","Inspiração","Mudança","Brilho","Horizonte",
    "Sopro","Ritmo","Memória","Aurora","Vínculo","Vento","Maré","Graça","Fagulha","Silêncio"
];
function shuffleArray(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }

/* Sequência e estado */
function gerarSequencia(n = 12){
    const pool = [...BASE];
    shuffleArray(pool);
    return pool.slice(0, n);
}
let palavras = gerarSequencia(12);
let index = -1;
let usadas = [];

/* Elementos */
const central = document.querySelector('#palavra-central .texto');
const burst = document.getElementById('burst');
const listaEl = document.getElementById('lista');
const btnAvancar = document.getElementById('btn-avancar');
const btnVoltar = document.getElementById('btn-voltar');
const btnGerar = document.getElementById('btn-gerar');
const btnShuffle = document.getElementById('btn-shuffle');
const inputRange = document.getElementById('timeRange');
const timeValue = document.getElementById('timeValue');
const timerEl = document.getElementById('timer');

/* =========================
   AUDIO (WebAudio)
   ========================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSwoosh() {
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(220, now);
    o.frequency.exponentialRampToValueAtTime(900, now + 0.22);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start(now);
    o.stop(now + 0.35);
}
function playClick(){
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.setValueAtTime(800, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start(now);
    o.stop(now + 0.14);
}

/* =========================
   HISTÓRICO: agora está estático e empurra para cima
   ========================= */
function atualizarLista(){
    // removemos apenas os itens antigos e re-populamos para manter ordem
    const existing = listaEl.querySelectorAll('.item');
    existing.forEach(n => n.remove());

    // queremos que o container fique alinhado em baixo (justify-end) e que as palavras cresçam para cima.
    // então adicionamos no fim da lista na ordem natural (antigas primeiro, novas por último),
    // e o CSS (justify-content:flex-end) garante que fiquem ancoradas embaixo.
    usadas.forEach((p) => {
        const div = document.createElement('div');
        div.className = 'item';
        div.textContent = p;
        listaEl.appendChild(div);
    });
}

/* =========================
   ANIMAÇÕES / TIPO MÁQUINA DE ESCREVER
   ========================= */
function typeText(fullText, node, cb){
    const speed = 36;
    node.textContent = '';
    node.classList.add('typewriter');
    let i = 0;
    function step(){
        if(i <= fullText.length - 1){
            node.textContent += fullText[i++];
            setTimeout(step, speed + Math.random()*28);
        } else {
            setTimeout(()=> node.classList.remove('typewriter'), 260);
            if(cb) cb();
        }
    }
    step();
}

function animateFlyingWord(text, onComplete){
    const flying = document.createElement('div');
    flying.className = 'flying';
    flying.style.left = (Math.random()*70 + 10) + '%';
    flying.style.top = (Math.random()*70 + 10) + '%';
    flying.style.fontSize = getComputedStyle(central).fontSize;
    flying.style.pointerEvents = 'none';
    flying.style.opacity = 0;
    flying.textContent = text;
    document.body.appendChild(flying);

    requestAnimationFrame(() => {
        flying.style.transition = 'transform 520ms cubic-bezier(.17,.84,.44,1), opacity 420ms ease';
        flying.style.opacity = 1;
        flying.style.transform = `translate3d(50vw,50vh,0px) translate(-50%,-50%) rotateX(0deg) rotateY(0deg) scale(1.02)`;
    });

    setTimeout(()=> {
        burst.classList.add('show');
        setTimeout(()=> burst.classList.remove('show'), 420);

        central.style.opacity = '0';
        central.style.transform = 'scale(0.96)';
        setTimeout(() => {
            typeText(text, central, () => {
                central.style.opacity = '1';
                central.style.transform = 'scale(1)';
                flying.remove();
                if(onComplete) onComplete();
            });
        }, 140);
    }, 400);

    playSwoosh();
}

/* =========================
   CONTROLE DE PALAVRAS (Avançar / Voltar / Gerar / Shuffle)
   ========================= */
function mostrarProxima(manual = true){
    // se não houver mais, criamos mais (comportamento infinito)
    if(index + 1 >= palavras.length){
        const mais = gerarSequencia(8);
        palavras = palavras.concat(mais);
        shuffleArray(palavras);
    }
    index++;
    const p = palavras[index];
    usadas.push(p);
    animateFlyingWord(p, () => {
        atualizarLista();
    });
    playClick();

    // se chamada manual por botão/tecla, iniciamos/reiniciamos o cronômetro
    if(manual) startTimerFromSlider();
}

function voltarAnterior(){
    if(usadas.length <= 1) return;
    // remove ultima mostrada
    const ultimo = usadas.pop();
    // reduzir index
    index = Math.max(0, index - 1);
    // recoloca último no futuro logo após o índice atual
    palavras.splice(index + 1, 0, ultimo);
    const atual = usadas[usadas.length - 1] || 'Pronto';
    // cancela timer e escreve a palavra anterior
    stopTimer();
    central.style.opacity = '0';
    setTimeout(()=> {
        typeText(atual, central, ()=> {
            central.style.opacity = '1';
            atualizarLista();
            playClick();
        });
    }, 180);
}

/* Embaralhar o restante (mantém já mostradas) */
function shuffleRemaining(){
    const remaining = palavras.slice(index + 1);
    shuffleArray(remaining);
    palavras = palavras.slice(0, index + 1).concat(remaining);
}

/* Gerar novas palavras e resetar */
function gerarNovas(){
    palavras = gerarSequencia(12);
    index = -1;
    usadas = [];
    central.textContent = 'Pronto';
    stopTimer();
    atualizarLista();
}

/* =========================
   TIMER: slider -> start/stop -> auto-advance
   ========================= */
let countdown = null; // id do setInterval
let timeLeft = 0;     // segundos restantes
function formatTime(s){
    const mm = Math.floor(s/60);
    const ss = s % 60;
    if(mm>0) return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    return `${String(ss).padStart(2,'0')}s`;
}

function updateTimerDisplay(){
    timerEl.textContent = formatTime(timeLeft);
}

function startTimerFromSlider(){
    // pega valor do slider (segundos)
    const seconds = parseInt(inputRange.value, 10) || 5;
    // se já estiver rodando, reinicia
    stopTimer();
    if(seconds <= 0) return;
    timeLeft = seconds;
    updateTimerDisplay();
    // iniciar contagem
    countdown = setInterval(()=> {
        timeLeft--;
        if(timeLeft <= 0){
            updateTimerDisplay();
            stopTimer();
            // auto avançar
            mostrarProxima(false); // false -> não reinicia timer duas vezes (essa chamada reiniciará manualmente)
            // reinicia timer automaticamente para próxima palavra
            startTimerFromSlider();
        } else {
            updateTimerDisplay();
        }
    }, 1000);
}

function stopTimer(){
    if(countdown !== null){
        clearInterval(countdown);
        countdown = null;
    }
    timeLeft = 0;
    updateTimerDisplay();
}

/* =========================
   EVENTOS UI / TECLADO
   ========================= */
btnAvancar.addEventListener('click', ()=> mostrarProxima(true));
btnVoltar.addEventListener('click', ()=> { voltarAnterior(); });
btnGerar.addEventListener('click', ()=> { gerarNovas(); playClick(); });
btnShuffle.addEventListener('click', ()=> { shuffleRemaining(); playClick(); });

document.addEventListener('keydown', (e) => {
    if(e.key === 'ArrowRight'){ e.preventDefault(); mostrarProxima(true); }
    if(e.key === 'ArrowLeft'){ e.preventDefault(); voltarAnterior(); }
});

/* Slider display */
inputRange.addEventListener('input', ()=> {
    timeValue.textContent = inputRange.value + 's';
});
timeValue.textContent = inputRange.value + 's';

/* desbloqueio audio em touch/click */
function unlockAudio(){
    if(audioCtx.state === 'suspended') audioCtx.resume();
    window.removeEventListener('touchstart', unlockAudio);
}
window.addEventListener('touchstart', unlockAudio, {passive:true});

/* Inicialização UI */
atualizarLista();
timerEl.textContent = '00:00';

/* =========================
   Fundo: partículas (estrelas)
   ========================= */
const canvas = document.getElementById('bg-canvas');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
const stars = [];
const STAR_COUNT = Math.round((W * H) / 42000) + 40;

function rand(min,max){ return Math.random()*(max-min)+min; }
function makeStars(){
    stars.length = 0;
    for(let i=0;i<STAR_COUNT;i++){
        stars.push({
            x: Math.random()*W,
            y: Math.random()*H,
            r: Math.random()*1.6 + 0.2,
            vx: (Math.random()-0.5)*0.15,
            vy: (Math.random()-0.5)*0.15,
            alpha: rand(0.06,0.9),
            twinkle: Math.random()*0.02 + 0.002
        });
    }
}

function draw(){
    ctx.clearRect(0,0,W,H);
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, 'rgba(12,8,20,0.35)');
    g.addColorStop(1, 'rgba(2,2,8,0.6)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    for(let s of stars){
        s.x += s.vx;
        s.y += s.vy;
        s.alpha += Math.sin(Date.now() * s.twinkle) * 0.0018;
        if(
